# 4.2 遅延最小化スケジューリング：交換議論

## review

最適性の示し方

- アルゴリズムの先進性(greedy algorithm stays ahead) - 任意のステップにおいて, 任意のアルゴリズムより優れていることを示す
- **交換議論(exchange argument) - 可能解を悪くすることなく交換していく方法** (←今回)

## 問題 4.2 遅延最小化スケジューリング

### 問題設定

- 単一の資源と、その資源をある時間だけ利用したいという $n$ 個の要求がある
- 資源は時刻 $s$ から利用可能
- 要求 $i$ は期限 $d_i$ をもつ
- 要求 $i$ は長さ $t_i$ の連続する時間だけ資源を利用する
- 受け入れた異なる要求には互いにかち合わない時間を割り当てる

### 入力（定数）

- $n$ - 要求の個数
- $s$ - 資源が利用可能となる時刻
- $d_i$ - 要求 $i$ の期限
- $t_i$ - 要求 $i$ が連続的に資源を専有する時間

### 変数

- $s(i)$ - 各要求 $i$ に対する開始時刻
  - （開始時刻を決定すると、終了時刻 $f(i)=s(i)+t_i$ も同時に決まる）

### 制約

- 任意の $i,j$ に対して、$(s(i),f(i)) \cap (s(j),f(j)) =\empty$

### 目的関数

- 決定された各要求の開始時刻 $s(i)$ に対して遅延 $l_i=\min{(f(i)-d_i, 0)}$ を定義する
  - $l_i>0$ のとき、要求 $i$ は遅れているという
- 最大遅延 $L=\max_{i}{l_i}$ を最小化する

## アルゴリズム 4.3 最大遅延最小化スケジューリングアルゴリズム

以下、要求を「ジョブ」と呼ぶ。

ジョブに関するデータの観察から、以下の自然なアルゴリズムを思いつく。

1. 専有時間 $t_i$ が小さい順番に処理する
    - 以下のインスタンスで最適解を得られない。ジョブ2の専有時間が多いものの、締切がジョブ1に比べ圧倒的に短いため遅延が発生してしまう
    ![Alt text](img/4.2_01.jpg)
2. 猶予時間 $d_i-t_i$ が小さい順に処理する
    - 1.の結果から猶予時間に基づいて、スケジューリングを行うが、残念ながらこれも上手く行かないインスタンスが存在する
　  ![Alt text](img/4.2_02.jpg)
