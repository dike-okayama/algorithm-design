# 4 章　グリーディアルゴリズム

## Introduction

一般に, **グリーディアルゴリズム**(greedy algorithm)の定義は難しい. ある基準に基づいて, 各ステップで近視眼的に最適化する判断を繰り返して解を作り上げていくアルゴリズムはグリーディ(貪欲)であると考えられる.  
グリーディアルゴリズムで最適解が得られる問題に対して, その最適性を証明するための次の二つの基本的な方法を説明する.

- アルゴリズムの先進性(greedy algorithm stays ahead) - 任意のステップにおいて, 任意のアルゴリズムより優れていることを示す
- 交換議論(exchange argument) - 可能解を悪くすることなく交換していく方法

二つの解析法を学んだ後, 次のような様々な問題を取り上げる.

- 最短パス問題(Shortest Path Problem)
- 最小全点木問題(Minimum Spanning Tree Problem)
- Huffman 符号の構成
- クラスタリング(clustering)
- 最小コスト有向木問題

## 4.1 区間スケジュール問題

区間スケジューリング問題を思い出す.

要求の集合 $\{1,2,\dots,n\}$ に対して, 開始時刻 $S(i)$ と終了時刻 $f(i)$ が与えられる. 部分集合は, どの二つの要素も時間がかち合わないとき, 共存可能(compatible)という. 共存可能な部分集合のうち最大のものを求めたい. また, この集合を, 最適である(optimal)と呼ぶ.

### アルゴリズム 4.1 区間スケジューリング問題に対するグリーディアルゴリズム(Greedy Interval Scheduling Algorithm)

区間スケジューリング問題に対する簡単なグリーディアルゴリズムのアイデアは以下の通りである.

1. 単純な規則を用いて最初の要求 $i_1$ を決定
1. $i_1$ と共存可能でない要求を排除
1. $i_1$ と共存可能な要求の中から単純な規則に基づいて $i_2$ を選ぶ
1. 共存可能な要求がなくなるまで以下繰り返し

どのような単純な規則を選ぶのかが重要. 自然ではあるが、良い解を与えないものも多く存在する.

最も自然と思われる規則をいくつか考察する.

1. 受け入れ可能な要求のうち, 開始時刻の最も早いものを選ぶ
1. 処理時間が最小になるもの
1. 共存不可能な要求が最小のものを選ぶ

それぞれについて詳しく考える.

1. 受け入れ可能な要求のうち, 開始時刻の最も早いものを選ぶ

この方法では最適解は得られない. 一つの要求が多くの時間を占めることになる可能性があり, 共存可能な部分集合のサイズを最も大きくするという目的には不適切.

![反例1](img/4.1_01.jpeg)

2. 処理時間が最小になるもの

すなわち, $f(i) - s(i)$ が最小になるものを選ぶ. これも最適解は得られない. ある最適な区間の間にある区間を含めてしまうような場合がある.

![反例2](img/4.1_02.jpeg)

3. 共存不可能な要求が最小のものを選ぶ

1 と 2 の規則の問題点は, それぞれの要求がかち合うことで, 要求を拒否せざるを得ないことにある. そこで, 排除すべき要求の数が最小のものを選んでいく. この方法はかなりよく思われるが, 最適解は得られない.

![反例3](img/4.1_03.jpeg)

最適解が得られるグリーディ規則は, 終了時刻の最も早い要求を選ぶことである. すなわち, $f(i)$ が最小となるような要求を選ぶ.  
形式的なアルゴリズムは以下.

> 最適な共存可能集合 $A$ を考えるグリーディアルゴリズム:
>
> > $R$ を全ての要求の集合とし, $A$ を空集合とする  
> > **While** $R$ が空でない  
> > &nbsp; &nbsp; 終了時刻が最小の要求 $i \in R$ を一つ選ぶ  
> > &nbsp; &nbsp; 要求 $i$ を $A$ に追加する  
> > &nbsp; &nbsp; 要求 $i$ とかち合うすべての要求を $R$ から削除する  
> > **Endwhile**  
> > 受け入れた要求の集合として $A$ を返す

### アルゴリズムの解析

このグリーディアルゴリズムは自然であるが, 自明ではない.  
共存可能性はすぐに得られる.

### _Fact_(4.1)

> $A$ は共存可能な要求な集合

#### _proof_

> アルゴリズムより明らか.

従って, $A$ が最適であることを示せばよい. ある最適な区間の集合を $\mathcal{O}$ として, $|A| = |\mathcal	{O}|$ を示す.  
最初に示したように, 各時点で $A$ が $\mathcal{O}$ に先進していることを示す.  
いくつかの記法を導入する. $i_1, \dots, i_k \in A$ として, 添字の順で $A$ に加えられたものとする. ここで, $|A| = k$ とする. 同様に, $j_1, \dots, j_m \in \mathcal{O}$ とする. $k=m$ を示せば良い. $j_i$ は左から並んでいるものとする.

**Rem**: $\mathcal{O}$ は共存可能な要求の部分集合であることから, 開始時刻の順と終了時刻の順は同じ

グリーディアルゴリズムは, 終了時刻の最も早いものを選ぶため, $f(i_1) \le f(j_1)$ が言える. より一般に, $f(i_r) \le f(j_r)(r=1,\dots,k)$ が得られる. これは, "先進している"ことを意味する.

**Rem**: 少なくとも $k \le m$

実際に命題として与える.

### _Prop_(4.2)

> すべての添え字 $r \le k$ に対して $f(i_r) \le f(j_r)$ である.

#### _proof_

> induction で示す.  
> $r = 1$ の時は明らか.  
> $r>1$ について, $f(i_{r-1}) \le f(j_{r-1})$ と仮定する.  
> すると, $\mathcal{O}$ の要素の添え字の規則から , $f(i_{r-1}) \le f(j_{r-1}) < s(j_r) $ であるため, $i_{r-1}$ と $j_r$ は共存可能. 帰納的に $^\forall{l} = 1,\dots,r-1$ について, $i_l$ と $j_r$ は共存可能. $f(i_r) > f(j_r)$ と仮定すると, $f(i_r)$ の最小性に矛盾(図 4.3 参照). よって, $r$ についても成立.  
> 従って, 任意の $r$ について命題は成立.

![証明](img/4.1_04.jpeg)
図(4.3)

グリーディアルゴリズムが最適解 $\mathcal{O}$ より先進することは示された. 次に, アルゴリズムが最適な集合 $A$ を返すことを確かめる.

### _Prop_(4.3)

> グリーディアルゴリズムは最適な集合 $A$ を返す.

#### _proof_

> $A$ が最適でないとする. ある最適な集合 $\mathcal{O}$ が存在する. $|A| = k, |\mathcal{O}| = m$ とすると, $m > k$ が言える. $r = k$ について, 命題 4.2 を適用すると, $f(i_k) \le f(j_k)$ が得られる. ここで, $\mathcal{O}$ には $j_{k+1}$ が含まれる. これは, 命題 4.2 の証明と同様に, $A$ の任意の要求と共存可能から $R$ に含まれる. しかし, $|A| = k$ より, この段階でアルゴリズムが終了しているため, $R$ は空でなくてはならない. 矛盾.  
> 従って, 題意は示された.

### 実装とアルゴリズム

$n$ この要求を, 終了時間について sort することで $\mathrm{O}(N\log{N})$ で解ける.

### 問題 4.1 区間分割(Interval Partitioning): 問題の背景と定式化

区間スケジューリング問題では, 一つの資源に対して, 利用時間帯が付随した要求が与えられた. それに対して, **区間分割問題**(Interval Partitioning Problem)は, 同等ないくつかの資源に対して, できるだけ短い資源を用いてすべての要求をスケジュールする問題である.  
例えば, すでに決まっている時間割に対して, 教室を割り当てるような問題である. 教室は資源で, 講義が要求となる. 使用する教室をできるだけ少なくするにはどうすれば良いかを考える.

### アルゴリズム 4.2 区間分割アルゴリズム(Interval Partitioning Algorithm)
