# 2.4 よく現れる計算時間の復習

我々の目標は、探索空間（可能解の集合）での全探索よりも効率の良いアルゴリズムを探し出すことであった。したがって、新しい問題に遭遇して解決する際には、以下の２種類の限界について検討することが重要である。

1. 達成したい計算時間に対する限界
2. 問題の自然な探索空間に対する限界（全探索アルゴリズムの計算時間）

## 線形時間（$\mathrm{O}(n)$ 時間）

### 最大値の計算．

$n$ 個の数の最大値の計算は、基本的な１回走査の "1-パス"（one-pass）で実行できる。

入力としてリストまたは配列で与えられる $a_1,a_2,\ldots,a_n$ をこの順に処理していきながら、それまでに得られた最大値を保持していく。

各要素に対して定数の量の仕事しかしないので、合計で $\mathrm{O}(n)$ の計算時間となる。

---

### 二つのソートリストのマージ（併合）．

単純な１回の走査を行うアルゴリズム以外でも、線形時間を達成する場合がある。

$n$ 個の数 $a_1,a_2,\ldots,a_n$ と $n$ 個の数 $b_1,b_2,\ldots,b_n$ の二つのリストが与えられ、それぞれは既にソートされているとする。これらの二つのリストをマージして一つの昇順のリスト $c_1,c_2,\ldots,c_{2n}$ にしたい。

今二つのリストの先頭を比べる。これら２つの要素のうち、小さい方が出力のリストの先頭になることがわかる。したがって、この小さいほうの要素を取り出し出力すべきリストに加え、残りの二つリストで同じことを繰り返せば、昇順に並んだリストが得られることがわかる。

---

二つのソート済みリスト $A=a_1,\ldots,a_n$ と $B=b_1,\ldots,b_n$ のマージ：

- 各リストで、リスト無いの場所を指すポインター **Current** を用意する
- 初期設定でそれぞれの先頭の要素を指すようにする
- $\text{While}$ 両方のリストがともに空でない：
  - **Current** ポインターが指す要素を $a_i$ と $b_j$ とする
  - 二つのうち小さいほうを出力のリストに追加する
  - 小さいほうの要素のあったリストの **Current** ポインターを一つ進める
- $\text{Endwhile}$
- 出力リストの後に空でないほうのリストをつないで出力する

---

```py
n: int
A: list[int]
B: list[int]

current_a = current_b = 0
out = []

while current_a < n and current_b < n:
    if A[current_a] < B[current_b]:
        out.append(A[current_a])
        current_a += 1
    else:
        out.append(B[current_b])
        current_b += 1

while current_a < n:
    out.append(A[current_a])
    current_a += 1

while current_b < n:
    out.append(B[current_b])
    current_b += 1

```

今回は最大値の計算の場合と異なり、各要素に対して $\mathrm{O}(n)$ 回比較されることがありうる。すべての要素について合計すると $\mathrm{O}(n^2)$ の計算時間が得られる。

これも正しい計算時間の上界であるが、出力されるリストへ要素が加えられる回数に着目するとより厳密な計算時間の上界が得られる。

ある要素が一度出力リストへ加えられると、その要素は入力の配列から削除され、それらの操作は定数時間である。出力リストへの追加は高々 $2n$ 回しか行われないので、全体としての計算量は $\mathrm{O}(n)$ となる。

## $\mathrm{O}(n\log{n})$ 時間

> これは、与えられた問題の入力を同じサイズの二つの部分に分割し、それぞれの部分を入力とする問題を再帰的に解いて、得られた二つの解を線形時間で組み合わせて最初の問題の解とするアルゴリズムの計算時間である。

最たる例がマージソートである。マージソートアルゴリズムは、入力の数の集合を等しいサイズの部分集合に分割し、それぞれの部分集合を再帰的にソートする。その後、二つのソート済みの部分をマージして一つの出力リストを得るというものである。

![merge sort](https://www.programiz.com/sites/tutorial2program/files/merge-sort-example_0.png)

### マージソート

```bash
$ cd code && python3 -m merge_sort

Running the Merge Sort Algorithm
> Press enter to continue ...

** Random Case 1 (N=10000) **
  input : [8665, 5365, 5270, 8026, 8265, 1338, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0350 seconds

** Random Case 2 (N=10000) **
  input : [1990, 6411, 3908, 4494, 6877, 6756, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0225 seconds

Task Completed
```

このアルゴリズムの計算時間が線形時間と対数時間の積で表されることは第５章で議論する。

$\mathrm{O}(n\log{n})$ が計算時間としてしばしば現れる理由は、単にアルゴリズムにおいて、ソートの部分がボトルネックになるからという場合が多い。

## 2 乗時間

> ２乗時間は、入力の要素のすべての対からなる探索空間を全探索し、各対については定数時間しか費やさないようなアルゴリズムの計算時間である。

### 最近点対問題（Closest Pair of Points Problem）

<!-- （参考: プログラミングコンテストチャレンジブック, p324） -->

平面上に $n$ 個の点がそれぞれ $(x,y)$ 座標で与えられ、これらの中で互いに最も近い２点（最近点対, closest pair of points）を求める問題を考える。

各点対の距離は定数時間で計算でき、２点の対の個数は $\binom{n}{2}=\frac{n(n-1)}{2}$ である。これは $\frac{1}{2}n$ で上から抑えられるので、全体としての計算時間は $\mathrm{O}(n^2)$ となる。

---

最近点対問題は、分割統治法に基づく $\mathrm{O}(n\log{n})$ アルゴリズムが存在する。また逐次添加法により $\mathrm{O}(n)$ にまで改善される。

---

## 3 乗時間

### $n$ 個の集合 $S_1,S_2,\ldots,S_n$ の互いに素な集合対の計算

$n$ 個の集合 $S_1,S_2,\ldots,S_n$ が与えられる。各集合 $S_i$ は $\{1,2,\ldots,n\}$ の部分集合である。このとき、これらの中に、互いに素な集合の対があるかどうかを知りたい。

$S_i$ のすべての要素を、１要素当り定数時間で列挙でき、さらに数 $p$ が与えられたとき、それが $S_i$ に属するかどうかを定数時間で判定できるとする。

集合の各対 $S_i$ と $S_j$ を列挙し、 $S_i$ の各要素 $p$ が $S_j$ に含まれるかを判定する。いずれの要素も片方の集合に含まれない場合、それらは互いに素な集合ということになる。

集合対の列挙に $\mathrm{O}(n^2)$ が、サイズ $\mathrm{O}(n)$ の集合の各要素が他の集合に含まれるかを判定するのに $\mathrm{O}(n)$ であるから、全体としての計算量は $\mathrm{O}(n^3)$ となる。

## $\mathrm{O}(n^k)$ 時間

> 任意の $k$ について、サイズ $k$ のすべての部分集合の探索空間を全探索すると、計算時間が $\mathrm{O}(n^k)$ のアルゴリズムが得られる。

### $n$ 点のグラフ $G$ がサイズ $k$ の独立集合をもつかどうかの判定

自然な解法は、 $k$ 点のすべての部分集合を列挙し、各部分集合 $S$ に対して、 $S$ の各２点間に辺があるかどうかを確かめるというものである。

$n$ 個の要素をもつ集合に対して $k$ 個の要素の部分集合の個数は全部で

$$
\binom{n}{k}=\frac{n(n-1)(n-2)\cdots(n-k+1)}{k(k-1)(k-2)\cdots(2)(1)}\le\frac{n^k}{k!}
$$

である。 $k$ は定数としているので、 $\binom{n}{k}=\mathrm{O}(n^k)$ である。また、サイズ $k$ の集合において、任意の２点の頂点の列挙に $\mathrm{O}(k^2)$ が、それらの間に辺が存在するかは定数時間で判定できるので、各部分集合が独立であるかの判定は $\mathrm{O}(k^2)$ でできる。よって全体の計算時間は $\mathrm{O}(k^2n^k)=\mathrm{O}(n^k)$ となる。

```py
# サイズ k の部分集合の列挙
comb = (1 << k) - 1
while comb < (1 << n):
    ...
    _x = comb & -comb
    _y = comb + _x
    comb = (((comb & -_y) // _x) >> 1) | _y
```

## 多項式時間を超えて

> すべての部分集合を考慮しなければならない全探索のアルゴリズムでは、その計算時間として $2^n$ が自然に現れる

### $n$ 点のグラフ $G$ の最大サイズの独立集合の計算

すべての部分集合を列挙し、その後はサイズ $k$ の場合と同様にして、その部分集合が独立であるかを判定すればよい。

$n$ 個の要素の集合の部分集合の総数は $2^n$ である。また、部分集合のサイズは $\mathrm{O}(n)$ なので、それが独立であるかどうかの判定は $\mathrm{O}(n^2)$ でできる。よって全体の計算時間として $\mathrm{O}(n^22^n)$ が得られる。

```py
# 全ての部分集合の列挙
for comb in range(1 << n):
    ...
```

---

このように解の探索空間が膨大になる問題では、非効率性が必然であるように思われる一方で、区間スケジューリング問題（第１章）のように、効率的なアルゴリズムを見つけることが可能となる場合も多い。このことをきちんと把握しておくことが重要である。

### 階乗（factorial）

> 階乗関数 $n!$ は、 $n$ 個のものを他の $n$ 個のものと対応づけるとき、それらを全探索するときに現れる計算時間である。また、 $n$ 個のものを順に並べるときのすべての並べ方を探索する場合にも現れる。

## 線形未満時間

> 入力がすべて読むのではなく、間接的に質問することによって入力が少しずつ与えられるような計算モデルにおいて、漸近的に線形時間より小さい計算時間に遭遇することもある。

### ソート済み配列からの要素検索

ソートされた配列 $A$ を入力とし、その中央の要素が目的の要素より大きいか小さいを調べる。（一致していれば終了する）。大きい場合は配列の左半分に、小さい場合は配列の右半分に目的の要素が存在することになり、再帰的に探索を行う。
