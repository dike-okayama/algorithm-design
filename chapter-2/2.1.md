# 2.1 計算容易性

## 効率性の定義の最初の試み

> 効率性の定義案（１）：アルゴリズムは、プログラムとして実装して実際の入力インスタンスに対して速く走る時、効率的であるという。

上記の定義にはいくつか重要なことが欠けている。

- アルゴリズムを**どこで**（where）そして**どのようにうまく**（how well）実装するかが未定義
  - 計算機の性能や実装のコーディングに依存
- "実際の"入力インスタンスが不明
  - 入力インスタンスの範囲は？
  - 扱いにくいインスタンスが入力でも適切に動作するか
- 将来の計算資源の拡充への考慮
  - 扱える入力サイズが増加した場合に、計算時間はどのように増加するのか

したがって、効率性の定義に求められるものは、

- プラットフォーム非依存
- 入力インスタンス非依存
- 入力サイズが増加したときの値が予測可能

のように、計算資源の使用量と入力サイズの関係を具体的に表現するものである。

## 最悪の場合の計算時間と全探索

アルゴリズムの計算時間を解析する上で、**最悪の場合**（worst-case）のインスタンスを与える場合と、ランダムに生成した入力インスタンスを与える**平均の場合**（average-case）の解析が行われる。

しかし、平均の場合の解析では、

- 入力インスタンスの範囲を表すのは非常に困難
- 実インスタンスが一様分布から生成されにくい
  - 特定のクラスのインスタンスに対して極端に低い性能を示す場合もある

の問題があり、本書では一般に最悪の場合の解析を考える。

---

（補足）平均の場合と最悪の場合の計算時間に乖離があるアルゴリズムとインスタンス

配列の最初の要素をピボットとして選択するクイックソートを考えると、既にソートされた（もしくはほとんどソートが完了している）インスタンスを与えると、性能は極端に悪化する。

```zsh
$ cd code && python3 -m quicksort

Comparison of Quicksort Speed Based on Different Instances
> Press enter to continue ...

** Random Case 1 (N=10000) **
  input : [7295, 6898, 9166, 1670, 8476, 1435, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0206 seconds

** Random Case 2 (N=10000) **
  input : [8750, 8924, 3848, 8367, 393, 5001, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0169 seconds

** Worst Case (N=10000) **
  input : [0, 1, 2, 3, 4, 5, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 2.6223 seconds

Task Completed
```

ランダムな入力ではまず最悪ケースを与えることはできないので、平均の場合の解析では問題となる。

---

一方で、自分で求めた計算時間の上界がどの程度か強力かを知るために、合理的なベンチマークが必要になる場合がある。最初の単純な道標としては、可能な解の探索空間上での全探索と比べることが挙げられる。

> 効率性の定義案（２）：アルゴリズムは、解析レベルで、全探索よりも本質的に良い最悪時性能を達成するとき、効率的であるという

- 全探索より改善された要因が、問題に対する示唆を与える
- "本質的に良い性能"とは？
  - 定量的な定義の重要性を示している

## 効率性の定義としての多項式時間

定数 $c>0$ と $d>0$ が存在し、サイズ $N$ のすべての入力インスタンスで、その計算時間が $cN^d$ 個の基本計算ステップで抑えられるとき、そのアルゴリズムは**多項式の計算時間**（polynomial running time）をもつ。あるいは、そのアルゴリズムは**多項式時間アルゴリズム**（polynomial-time algorithm）であるという。

> 効率性の定義案（３）：アルゴリズムは、多項式の計算時間をもつとき、効率的であるという。

この定義の下では、 $n^{100}$ に比例するような多項式アルゴリズムも効率的であるということになる。その一方で、（計算時間上でははるかに高速に動作するように思われる） $n^{1+0.02\log{n}}$ に比例する非多項式アルゴリズムは効率的であるとはいえない。

それでも効率性の評価に多項式時間アルゴリズムの有無を考慮するには以下の理由がある。

- 実際の問題において、多項式時間の数学的定義と、アルゴリズムの効率性や計算容易性で観察されることが、驚くほど良く適合
  - 多項式時間アルゴリズムが存在する問題は、たいていの場合ほどほどの多項式に比例する計算時間のアルゴリズムを持つ
  - 多項式時間アルゴリズムが存在しない問題は、実際にはとても難しいものになるのが普通
- 多項式と指数関数の増加率の差がとてつもなく大きい

この具体的な定義によって得られる一番の恩恵は、**ある特定の問題に対して効率的なアルゴリズムが存在しない**という概念が表現可能になる点である。
