# 2.1 計算容易性

## 効率性の定義の最初の試み

> 効率性の定義案（１）：アルゴリズムは、プログラムとして実装して実際の入力インスタンスに対して速く走る時、効率的であるという。

上記の定義にはいくつか重要なことが欠けている。

- アルゴリズムを**どこで**（where）そして**どのようにうまく**（how well）実装するかが未定義
  - 計算機の性能や実装のコーディングに依存
- "実際の"入力インスタンスが不明
  - 入力インスタンスの範囲は？
  - 扱いにくいインスタンスが入力でも適切に動作するか
- 将来の計算資源の拡充への考慮
  - 扱える入力サイズが増加した場合に、計算時間はどのように増加するのか

したがって、効率性の定義に求められるものは、

- プラットフォーム非依存
- 入力インスタンス非依存
- 入力サイズが増加したときの値が予測可能

のように、計算資源の使用量と入力サイズの関係を具体的に表現するものである。

## 最悪の場合の計算時間と全探索

アルゴリズムの計算時間を解析する上で、**最悪の場合**（worst-case）のインスタンスを与える場合と、ランダムに生成した入力インスタンスを与える**平均の場合**（average-case）の解析が行われる。

しかし、平均の場合の解析では、

- 入力インスタンスの範囲を表すのは非常に困難
- 実インスタンスが一様分布から生成されにくい
  - 特定のクラスのインスタンスに対して極端に低い性能を示す場合もある

の問題があり、本書では一般に最悪の場合の解析を考える。

---

e.g. 平均の場合の解析が問題となるアルゴリズムとインスタンス

配列の最初の要素をピボットとして選択するクイックソートを考えると、既にソートされた（もしくはほとんどソートが完了している）インスタンスを与えると、性能は極端に悪化する。

```zsh
$ cd code && python3 -m quick_sort

Comparison of Quick Sort Speed Based on Different Instances
> Press enter to continue ...

** Random Case 1 (N=10000) **
  input : [7295, 6898, 9166, 1670, 8476, 1435, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0206 seconds

** Random Case 2 (N=10000) **
  input : [8750, 8924, 3848, 8367, 393, 5001, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 0.0169 seconds

** Worst Case (N=10000) **
  input : [0, 1, 2, 3, 4, 5, ...]
  output: [0, 1, 2, 3, 4, 5, ...]
  Took 2.6223 seconds

Task Completed
```

---
